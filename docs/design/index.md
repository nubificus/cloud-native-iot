# **KubeChoros: A Cloud-Native IoT Solution**

#### **1\. Executive Summary**

KubeChoros is a secure, cloud-native IoT platform designed to simplify the
management and orchestration of IoT devices across edge and cloud environments.
Built on Kubernetes, KubeChoros provides key features such as secure device
onboarding, efficient communication mechanisms, robust over-the-air (OTA)
updates, and seamless integration with Akri for device discovery and resource
management.

#### **Objectives**

- Simplify **device onboarding** with built-in security mechanisms.
- Enable **real-time communication** with robust TLS support (using mbedTLS).
- Provide **OTA update capabilities** for seamless software deployment.
- Leverage **Kubernetes-native tools** (e.g., Akri with custom CRDs) for
  dynamic resource discovery and orchestration.

#### **High-Level Architecture**

##### **Layers Overview**

1. **Device Layer**
   - IoT devices like ESP32, ESP32-S2 and ESP32-S3, preloaded with UDS (Unique Device Secrets).
   - Entity Attestation Tokens (EATs) for secure onboarding.
   - Simple Management API endpoints (REST).
2. **Edge Layer**
   - Lightweight Kubernetes clusters (K3s) for edge computing.
   - Akri for IoT-specific device discovery and resource allocation.
   - A custom operator & Custom Resource Definition (CRD) for cloud-native OTA updates.
3. **Cloud Layer**
   - Centralized Kubernetes clusters with advanced orchestration.
   - Cloud-based device management, analytics, and OTA update services.
4. **Application Layer**
   - Web-based dashboards and APIs for monitoring, control, and device insights.

#### **Detailed Architecture**

#####

##### **Secure Device Onboarding**

- **Unique Device Secrets (UDS)**: Embedded in devices during manufacturing for cryptographic identity.
- **Entity Attestation Tokens (EATs)**: Used to authenticate devices upon initial onboarding.
- **Board Ledger**: Maintains a registry of manufacturer-issued certificates to validate devices.
- **Onboarding Process**:
  1. Akri’s initial discovery handler (DH1) finds an AP with a specific SSID
     (hashed using a board unique identifier from the ledger). The discovery
     handler connects to this AP and sets up credentials for the site’s IoT WiFi
     network.
  2. The device reboots and connects to the site’s IoT WiFi network.
  3. The board discovery handler (DH2) scans the site’s IoT WiFi network for
     devices with a specific type (/type endpoint) and initiates the
     onboarding process.
  4. The device generates the EAT, encrypts it using the key derived from the
     UDS and signs it using the attestation certificate. The payload is sent
     to the onboarding process (DH2).
  5. The board discovery handler (DH2) relays the payload to the attestation
     server. If the attestation server responds with an ACK, the discovery
     handler continues with onboarding the device (send to agent/controller,
     populate akri instances etc.).
  6. Once validated, the device is added to the KubeChoros ecosystem.

**(!) Current State**

**Assumptions:**

- The device contains a Unique Device Secret coming from its Vendor, and can
  only be read by the bootloader. In our case, we use the MAC, which we assume
  is a UDS.
- The attestation certificate is generated by the device at early boot time
  (using the UDS), and can’t be generated anywhere else, since there’s no
  access to the UDS. In our case we generate it in application, which is not very
  safe.

**Root Certificate - Public:** The root certificate of each device is coming
from its vendor. This means that every time we get a new device, we also get
its root certificate, which is unique for each board, and remains the same even
if we change its firmware or its bootloader. And that’s because the root
certificate is generated using the Unique Device Secret.

More specifically, it is generated through generate_uds_cert(), which receives
a key as input. The key buffer comes from a Key Derivation Function (KDF),
using the MAC address and a 64 bytes salt (common to host and device).

**Device - Attestation Certificate:** It is presumably generated in the device
at early boot time (assumption 2). Except for the Unique Device Secret, the
generator also uses the bootloader hash and the application hash.

The verification process involves the transfer of the attestation certificate
to the attestation server. The server has access to the corresponding (public)
root certificate and verifies the Attestation Cert. against the Root (that is,
confirm they are a pair). By following this process, we make sure that the
board is authorized to receive a new firmware image and update.

Essentially, the verification of an attestation certificate against the root can be achieved with the following command:  
openssl verify -verbose -ignore_critical -CAfile root.pem attestation.pem

##### **4.2 Attestation Server**

The attestation server verifies the EAT obtained from the device against the ledger of existing board certificates from the vendor. The ledger maintains a registry of manufacturer-issued certificates to validate devices.

TODO:  
1\. Explore attestation server (what input it gets, what format, how it uses it)

2\. Embed extra info in the process through EAT or Attastation Certificate to verify firmware version and device type.

##### **Communication Mechanism**

- **TLS with mbedTLS**:
  - Secure communication between devices, edge nodes, and the cloud.
  - Lightweight implementation tailored for resource-constrained devices like ESP32, ESP32-S2 and ESP32-S3.

##### **Integration with Akri**

- **Device Discovery**: Automatically identifies and registers devices in the Kubernetes cluster.
- **Resource Allocation**: Akri maps discovered devices to workloads based on predefined policies and annotations.

##### **OTA Updates**

- **OTA Update Process**:
  1. The KubeChoros operator receives a request to re-purpose one or more devices.
  2. The operator queries the k8s database for Akri instances matching the repurpose filter and spawns flashjob pods with the respective parameters:
     - Flashjob endpoint IP (host IP)
     - Flashjob container image
     - Device IP endpoint
     - Device firmware OCI image
     - ???
  3. Service for creation of external IPs to give a routable IP in the flashjobs, which will be the IP of the OTA process.
  4. The Flashjob pod is spawned and issues an API call to trigger the OTA process on the device.
  5. The Device starts the OTA update process, following the same process as
     in the onboarding case (steps 4-5). Once the validation is complete, the
     device listens for firmware updates by the flashjob pod.
  6. The device requests the updated firmware from the flashjob
  7. The device reboots to the updated firmware and should probably go
     through the onboarding process again (steps 3-6).
- **Delta Updates**: Minimized bandwidth usage by packaging the firmware in OCI
  images and grouping applications into OCI manifests.

##### **Data Flow**

1. Devices publish telemetry securely to broker pods, running on edge nodes.
2. Edge nodes process data locally and forward aggregated insights to the cloud.
3. Control signals and OTA updates are sent back to devices.

##### **Integration with vAccel**

A key optimization extension to KubeChoros is the vAccel integration, the
vAccel framework to offload compute-intensive applications for ESP32-based IoT
devices to neighboring nodes equipped with GPUs/TPUs etc. This extension
bridges the IoT, edge, and cloud layers, enabling resource-constrained devices
to offload compute-intensive tasks to neighboring edge nodes, thus enhancing
application performance and efficiency.

**Offers:**

1. Unified API for hardware-agnostic access to accelerators like GPUs, TPUs, and FPGAs.
2. Modular, plugin-based architecture for flexible integration across diverse hardware and transport layers.
3. Efficient communication mechanism between IoT devices and edge nodes.
4. Ensures seamless interoperability in the IoT-Edge-Cloud continuum.

#### **Technical Highlights:**

- **AI/ML Offloading**: vAccel extensions to support TFlite/micro and TVM micro ML API calls. These tasks are forwarded to edge nodes via a vAccel RPC agent, enabling efficient AI inference close to the source.
- **Edge-Accelerated Inference**: IoT devices offload AI workloads to edge nodes equipped with vAccel-supported hardware accelerators.
- **Dynamic Device Repurposing**: Through OTA updates, devices can be reconfigured for new tasks, promoting resource flexibility within the KubeChoros ecosystem.

#### **Benefits:**

- Significantly reduces latency for compute-intensive operations.
- Optimizes resource utilization by offloading tasks to edge accelerators.

#### **Deployment Strategies**

##### **Infrastructure Requirements**

- **Device Layer**: Support for ESP32, ESP32-S2, ESP32-S3, or similar devices.
- **Edge Layer**: Kubernetes distributions like K3s with Akri installed.
- **Cloud Layer**: Scalable Kubernetes cluster with secure CI/CD pipelines for OTA updates.

##### **Networking and Security**

- **Zero Trust Architecture**: Ensures secure communication across all layers.
- **Zero Touch Architecture**: Ensures minimal user intervention for device onboarding (only the manufacturer should supply a device certificate).

#### **Use Cases**

- **Smart Agriculture**: Automated sensor data collection and analysis.
- **Industrial IoT**: Secure monitoring and OTA updates for factory equipment.
- **Healthcare IoT**: Secure and reliable device management for medical applications.

#### **Roadmap**

- **MVP (Q4 2024)**: Core features, including secure onboarding, Akri integration, basic OTA updates, TinyML application deployment.
- **Phase II (Q1 2025)**: Advanced features, such as neighboring node offloading (vAccel).
- **Phase III (Q2 2025)**: Advanced device analytics, federated learning, and multi-cloud support.
- **Phase IV (Q3 2025)**: Full-scale deployments with high-level automation and AI/ML integration.

#### **Conclusion**

KubeChoros harnesses the power of Kubernetes to deliver a secure, scalable, and
extensible IoT platform. By integrating cutting-edge features like secure
onboarding, Akri-based resource management, and robust communication
mechanisms, it stands as a next-generation solution for cloud-native IoT
ecosystems.
