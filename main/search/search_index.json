{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Cloud-Native IoT","text":"<p>Welcome to the documentation for our Cloud-Native IoT Platform\u2014an end-to-end system designed for secure onboarding, efficient resource discovery, over-the-air updates, and task offloading across the edge\u2013cloud continuum.</p> <p>This site serves as the central hub for all documentation related to the platform's architecture, components, APIs, and integration patterns.</p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>Zero-touch secure device onboarding (DICE-based)</li> <li>Seamless OTA updates for ESP32 and Linux-class devices</li> <li>Akri-based device discovery and inventory creation</li> <li>vAccel-powered offloading to heterogeneous accelerators</li> <li>Kubernetes-native architecture (CRDs, Operators)</li> </ul>"},{"location":"#target-audience","title":"Target Audience","text":"<ul> <li>Platform developers</li> <li>System integrators</li> <li>Edge/cloud orchestrator maintainers</li> <li>Embedded/IoT engineers</li> </ul> <ul> <li> <p> Get started</p> <p> Start here</p> </li> <li> <p> Components</p> <p>Browse through the system basic components</p> <p> View Components</p> </li> <li> <p> Developers</p> <p>Discover how you can contribute!</p> <p> Developer</p> </li> </ul>"},{"location":"faq/","title":"Frequently Asked Questions","text":""},{"location":"api/","title":"Overview","text":"<p>The Cloud-Native IoT platform exposes a set of RESTful APIs designed to facilitate secure device onboarding, firmware updates, and device discovery through Akri. These endpoints are structured to support both microcontroller-class (e.g., ESP32) and Linux-class devices across the edge\u2013cloud continuum.</p> <p>This section provides a detailed look at two core API groups:</p> <ul> <li>Device API   The Device API handles the lifecycle of IoT devices within the platform. From onboarding to firmware updates, these endpoints are responsible for ensuring secure and seamless device interactions.</li> </ul>"},{"location":"api/openapi-spec/","title":"Device API","text":"<p>Version: 0.1.0 Base path: (Device-local address, e.g., <code>http://{device-ip}</code>)</p>"},{"location":"api/openapi-spec/#endpoints","title":"\ud83d\udccb Endpoints","text":""},{"location":"api/openapi-spec/#get-manageinfo","title":"<code>GET /manage/info</code>","text":"<p>Summary: Get device information Description: Retrieve static information about the IoT device.</p> <p>Responses:</p> <ul> <li><code>200 OK</code>: JSON representation of the device</li> </ul> <pre><code>{\n  \"device\": \"generic-iot-device\",\n  \"application\": \"example-app\",\n  \"version\": \"1.0.0\"\n}\n</code></pre>"},{"location":"api/openapi-spec/#get-manageonboard","title":"<code>GET /manage/onboard</code>","text":"<p>Summary: Retrieve attestation certificate Description: Obtain the device\u2019s attestation certificate in PEM format.</p> <p>Responses:</p> <ul> <li><code>200 OK</code>: PEM-encoded certificate (Content-Type: <code>application/x-pem-file</code>)</li> <li><code>500 Internal Server Error</code>: Certificate retrieval error</li> </ul> <p>Example Error:</p> <pre><code>{\n  \"error\": \"Internal error\",\n  \"details\": \"Stack trace or detailed error info\"\n}\n</code></pre>"},{"location":"api/openapi-spec/#post-manageupdate","title":"<code>POST /manage/update</code>","text":"<p>Summary: Start OTA firmware update Description: Initiates an Over-the-Air update using the provided image and optional arguments.</p> <p>Request Body (application/json):</p> <pre><code>{\n  \"image\": \"harbor.nbfc.io/drop/temp-sensor-capture:v0.1.0\",\n  \"params\": [\"server\", \"192.168.1.100\"]\n}\n</code></pre> <p>Responses:</p> <ul> <li><code>200 OK</code>: Update initiated</li> <li><code>400 Bad Request</code>: Invalid update request</li> <li><code>500 Internal Server Error</code>: Update process failed</li> </ul> <p>Error Example:</p> <pre><code>{\n  \"error\": \"Internal error\",\n  \"details\": \"Stack trace or detailed error info\"\n}\n</code></pre>"},{"location":"api/openapi-spec/#get-appinfo","title":"<code>GET /app/info</code>","text":"<p>Summary: Get app information Description: Retrieve static information about the deployed application on the IoT device.</p> <p>Responses:</p> <ul> <li><code>200 OK</code>: JSON representation of the app</li> </ul> <pre><code>{\n  \"device\": \"temp-sensor\",\n  \"application\": \"temp-sensor-capture\",\n  \"image\": \"harbor.nbfc.io/drop/temp-sensor-capture:v0.1.0\",\n  \"version\": \"1.0.0\"\n}\n</code></pre>"},{"location":"architecture/","title":"Architecture Overview","text":"<p>Our Cloud-Native IoT Platform is designed to securely manage heterogeneous IoT devices and applications across edge and cloud environments. It combines trusted onboarding, modular &amp; secure OTA updates, dynamic discovery based on Akri, and resource offloading within a Kubernetes-native control plane.</p>"},{"location":"architecture/#layers-of-the-architecture","title":"Layers of the Architecture","text":"<ul> <li>Device Layer: ESP32 and Linux-class devices capable of secure boot and attestation (via DICE).</li> <li>Edge Layer: Lightweight Kubernetes clusters or single-node runtimes (e.g., K3s, MicroK8s) managing Akri, OTA agents, and agents to provide compute off-loading capabilities to clients.</li> <li>Cloud/Orchestrator Layer: Manages policies, metadata, and orchestrates device lifecycle, offloading targets, and OTA operations.</li> </ul> <p>Figure 1 presents a high-level architecture diagram of our framework.</p> <p></p>"},{"location":"architecture/#key-technologies","title":"Key Technologies","text":"<ul> <li>Akri for device discovery and Kubernetes resource mapping.</li> <li>DICE Device Identifier Composition Engine) for secure onboarding.</li> <li>vAccel for portable compute offloading.</li> <li>mbedTLS for all device-to-cloud communications.</li> <li>Custom Operators/CRDs for OTA and offloading management.</li> </ul>"},{"location":"architecture/#key-components","title":"Key Components","text":"<ul> <li>Attestation Server</li> <li>OTA Service</li> <li>OTA Agent</li> <li>Discovery Endpoints</li> </ul> <p>For a component-level breakdown, see Components.</p>"},{"location":"components/","title":"Cloud-native IoT Project Components Overview","text":"<p>This document provides a high-level overview of the key components that make up the Cloud-native IoT project.</p>"},{"location":"components/#secure-onboarding-device-registration","title":"Secure Onboarding &amp; Device Registration","text":"<ul> <li>DICE-based Attestation server: Simple entity deployed in a secure enclave that validates DICE certificates generated from leaf devices.</li> <li>Onboarding and OTA update Service: Component that integrates with the user application and provides endpoints to propagate general and attestation information to the rest of the system.</li> <li>Enhanced Akri Discovery Handler: Facilitates dynamic discovery and inventory of IoT devices within Kubernetes clusters, based on Akri.</li> </ul>"},{"location":"components/#ota-over-the-air-update-framework","title":"OTA (Over-The-Air) Update Framework","text":"<ul> <li>OTA Agent: Manages firmware fetch and provides the update endpoint for devices.</li> <li>OTA Service: Runs on devices to securely receive, verify, and apply firmware updates.</li> <li>TLS Security: Ensures encrypted communication and integrity of update payloads.</li> </ul>"},{"location":"components/#cloud-native-infrastructure","title":"Cloud-Native Infrastructure","text":"<ul> <li>Kubernetes &amp; Operators: All components are deployed and managed using Kubernetes primitives, custom resource definitions (CRDs), and operators.</li> <li>Application building &amp; packaging: All components are built and packaged using standard cloud-native tooling.</li> </ul>"},{"location":"components/akri-dh/","title":"Akri Discovery Handler","text":""},{"location":"components/akri-integration/","title":"Akri Integration for Onboarding","text":"<p>We extend Akri's discovery handler mechanism to incorporate device verification before exposing devices as Kubernetes resources.</p>"},{"location":"components/attestation-server/","title":"Attestation Server","text":"<p>The attestation server is actually an HTTP server connected to a Redis database. The database is used to hold all the available device root certificates with their key (ie the MAC address). Therefore, the database could be simply described by the following table:</p> Key Certificate MAC-1 Root Cert 1 MAC-2 Root Cert 2 ..... ...... MAC-N Root Cert N <p>Thus, whenever the attestation server receives an incoming POST request with an attestation certificate on its body, it traverses its database to check whether there is any certificate that verifies the given one. In case of verification, it responds with a <code>200 OK</code> HTTP code. Otherwise, the client will receive some error HTTP code. Attestation Server</p>"},{"location":"components/attestation-server/#dice","title":"Dice","text":"<p>DICE certificates are digital certificates issued as part of the DICE architecture, which is a chain-of-trust framework. We use DICE certificates to verify the devices of our fleet. For each device, there is a pair of DICE certificates: the root and the attestation certificate.</p>"},{"location":"components/attestation-server/#assumptions","title":"Assumptions","text":"<ul> <li>The device contains a Unique Device Secret coming from its Vendor, and can   only be read by the bootloader. In our case, we use the MAC, which we assume   is a UDS.</li> <li>The attestation certificate is generated by the device at early boot time   (using the UDS), and can\u2019t be generated anywhere else, since there\u2019s no   access to the UDS. In our case we generate it in application, which is not very   safe.</li> </ul>"},{"location":"components/attestation-server/#root-certificate-public","title":"Root Certificate - Public","text":"<p>The root certificate of each device is coming from its vendor. This means that every time we get a new device, we also get its root certificate, which is unique for each board, and remains the same even if we change its firmware or its bootloader. And that\u2019s because the root certificate is generated using the Unique Device Secret. More specifically, it is generated through <code>generate_uds_cert()</code>, which receives a key as input. The key buffer comes from a Key Derivation Function (KDF), using the MAC address and a 64 bytes salt (common to host and device).</p>"},{"location":"components/attestation-server/#device-attestation-certificate","title":"Device - Attestation Certificate","text":"<p>It is presumably generated in the device at early boot time (assumption 2). Except for the Unique Device Secret, the generator also uses the bootloader hash and the application hash. The verification process involves the transfer of the attestation certificate to the attestation server. The server has access to the corresponding (public) root certificate and verifies the Attestation Cert. against the Root (that is, confirm they are a pair). By following this process, we make sure that the board is authorized to receive a new firmware image and update. Essentially, the verification of an attestation certificate against the root can be achieved with the following command:</p> <pre><code>openssl verify -verbose -ignore_critical -CAfile root.pem attestation.pem\n</code></pre>"},{"location":"components/attestation-server/#dice-source","title":"Dice source","text":"<p>The source code used to generate both root and attestation Dice certificates can be found in our github repo <code>nubificus/nbfc-dice</code>. In <code>nbfc-dice/src/main.c</code> there's a host-side program that builds both the root and attestation certificate in DER format, using the UDS and hashes like firmware image hash, or bootloader hash. Saying that, a certificate in binary format (DER) can be transformed to text-based (PEM) using the following OpenSSL command:</p> <pre><code>openssl x509 -inform der -in cert.der -out cert.pem\n</code></pre> <p>On the other side, a piece of code that generates the attestation certificate on the device side can be found in <code>nbfc-dice/dice_esp32_app/main/dice_app_example_main.c</code>.</p>"},{"location":"components/esp32-akri/","title":"esp32-akri","text":"<p>ESP32 Component for managing the akri-related http endpoints of the device. The component does not contain the handlers, only the functions to setup handlers for the akri-specific endpoints. The corresponding handler functions are contained into the <code>ota-service</code> component.</p>"},{"location":"components/esp32-akri/#how-to-use","title":"How to use","text":"<pre><code>cd &lt;path-to-your-esp-idf-project&gt;\nmkdir -p components\ncd components\ngit clone https://github.com/nubificus/esp32-akri.git\n</code></pre> <p>Add the component to your project by simply adding the following line inside <code>idf_component_register()</code> of <code>&lt;path-to-your-esp-idf-project&gt;/main/CMakeLists.txt</code>:</p> <pre><code>REQUIRES esp32-akri\n</code></pre> <p>E.g:</p> <pre><code>idf_component_register(SRCS \"test.c\"\n                       INCLUDE_DIRS \".\"\n                       REQUIRES esp32-akri)\n</code></pre> <p>Afterwards, you can include the component's header file:</p> <pre><code>#include \"esp32-akri.h\"\n</code></pre>"},{"location":"components/esp32-akri/#api-reference","title":"API Reference","text":"<pre><code>int akri_server_start();\n\nint akri_server_end();\n\nint akri_set_update_handler(esp_err_t (*handler)(httpd_req_t *req));\n\nint akri_set_info_handler(esp_err_t (*handler)(httpd_req_t *req));\n\nint akri_set_onboard_handler(esp_err_t (*handler)(httpd_req_t *req));\n\nint akri_set_temp_handler(esp_err_t (*handler)(httpd_req_t *req));\n\nint akri_set_handler_generic(const char *uri,\n                             httpd_method_t method,\n                             esp_err_t (*handler)(httpd_req_t *req));\n</code></pre> <p>Make sure you have connected the device on the internet previously.</p>"},{"location":"components/esp32-akri/#endpoints","title":"Endpoints","text":"<p>The exported endpoints from esp32-akri are:</p> <ul> <li><code>/info</code></li> <li><code>/onboard</code></li> <li><code>/update</code></li> </ul>"},{"location":"components/esp32-akri/#info","title":"<code>/info</code>","text":"<p>By sending a GET request to <code>/info</code>, one can retrieve information about the device (device type, firmware version, firmware type etc) in JSON format.</p>"},{"location":"components/esp32-akri/#update","title":"<code>/update</code>","text":"<p>On the other side, the update should be initialized through a POST request. More specifically, the body of the request should include the IP address of the OTA agent in the form: \"ip: A.B.C.D\". The handler then will extract the IP from the request and initialize a TLS (secure) connection between the device and the Agent. If the authentication succeeds, the device will receive the new firmware.</p>"},{"location":"components/esp32-akri/#onboard-fixme","title":"<code>/onboard</code> (FIXME)","text":"<p>Currently, the <code>/onboard</code> endpoint waits for GET requests, and responds with the Attestation Certificate in PEM format. The purpose of this endpoint is to enable the onboarding process of the device. Important!! However, the current state is not secure at all, since the certificate is not transferred over a TLS connection, thus it could get stolen by a malicious user with the upper goal to impersonate a trusted device. Saying that, this endpoint should probably receive POST requests, containing the IP address of an external TLS server that could communicate securely with the IoT.</p>"},{"location":"components/firmware-signing/","title":"Firmware Signing","text":"<p>Firmware authenticity and integrity are essential to prevent malicious updates and bricking attacks.</p>"},{"location":"components/firmware-signing/#signing-workflow","title":"Signing Workflow","text":"<ol> <li>Firmware is signed using an offline private key.</li> <li>OTA Service embeds signature in metadata descriptor.</li> <li>OTA Agent verifies the signature before applying the update.</li> </ol>"},{"location":"components/firmware-signing/#cryptographic-tools","title":"Cryptographic Tools","text":"<ul> <li>ed25519 or ECDSA for digital signatures</li> <li>SHA-256 checksum for integrity verification</li> <li>mbedTLS used for TLS and crypto on-device (ESP32)</li> </ul>"},{"location":"components/firmware-signing/#example-signing-script","title":"Example Signing Script","text":"<pre><code>openssl dgst -sha256 -sign fw-private.pem -out firmware.sig firmware.bin\n</code></pre> <pre><code>{\n  \"version\": \"1.3.2\",\n  \"signature\": \"base64:MEUCIQD...\",\n  \"checksum\": \"sha256:...\",\n  \"public_key_hint\": \"esp32_ca\"\n}\n</code></pre>"},{"location":"components/flashjob/","title":"FlashJob","text":""},{"location":"components/mbedtls/","title":"mbedTLS","text":""},{"location":"components/ota-agent/","title":"OTA Agent","text":"<p>The OTA agent is responsible for communicating with the device and for authenticating it. Actually, the program operates as a TLS server (thus, the communication is secure) and waits for an upcoming connection from the microcontroller that has been requested to update its firmware. As being described in Figures 1 and 2, when it's about to update, the microcontroller will receive a POST request to its <code>/update</code> endpoint. The request will contain an IP address on its body, like <code>ip: A.B.C.D</code>. This IP belongs to the agent, which should have been executed earlier. The agent requires the following arguments to run, which are given as environment variables:</p> <ul> <li><code>NEW_FIRMWARE_PATH</code>: The path to the firmware that will be sent to the   microcontroller (on success)</li> <li><code>DICE_AUTH_URL</code>: The URL to connect to Dice-Auth HTTP server, to authenticate   the connected microcontroller. Under the hood, the agent will send the   received Attestation Certificate, while Dice-Auth will verify it against the   saved Root certificates.</li> <li><code>SERVER_CRT_PATH</code>: The certificate to be used by the TLS server. It can be   generated using commands like <code>openssl genpkey -algorithm RSA -out key.pem</code>   and <code>openssl req -new -x509 -key key.pem -out cert.pem -days 365</code>.</li> <li><code>SERVER_KEY_PATH</code>: The private key to be used by the TLS server. Can be   generated as shown above.</li> </ul> <p>The OTA Agent runs on each device and manages update retrieval and installation in a secure and verifiable manner.</p>"},{"location":"components/ota-agent/#responsibilities","title":"Responsibilities","text":"<ul> <li>Fetch updates from global registry</li> <li>Relay update to leaf device</li> </ul>"},{"location":"components/ota-agent/#supported-devices","title":"Supported Devices","text":"<ul> <li>ESP32: Written in C, flashes new firmware via <code>esp32_ota_update</code> API.</li> <li>Linux-class: Deploys updated container image.</li> </ul>"},{"location":"components/ota-agent/#configuration","title":"Configuration","text":"<ul> <li><code>OTA_ENDPOINT</code>: URL of OTA Service</li> <li><code>DEVICE_ID</code>: Unique identifier for the device</li> <li><code>TLS_CERT_PATH</code> / <code>TLS_KEY_PATH</code>: For secure communication</li> </ul>"},{"location":"components/ota-agent/#example-flow","title":"Example Flow","text":"<ol> <li>Agent contacts device to initiate the update process.</li> <li>Device contacts Agent to establish TLS connection and provide its certificate.</li> <li>Agent verifies device's identity and moves on to the update process.</li> <li>Agent downloads firmware blob via HTTPS.</li> <li>Agent writes the firwware blob on a listening port of the device.</li> <li>Device checks &amp; verifies the newly fetched firmware.</li> <li>Device applies update and reboots.</li> </ol> <p>Updates are only allowed for devices that passed DICE-based onboarding.</p>"},{"location":"components/ota-agent/#build","title":"Build","text":"<pre><code>git clone https://github.com/nubificus/ota-agent.git --recursive\ncd ota-agent\ncd  mbedtls &amp;&amp; git submodule update --init &amp;&amp; make -j$(nproc) &amp;&amp; cd -\nmake\n</code></pre>"},{"location":"components/ota-service/","title":"OTA Service","text":"<p>The OTA Service is an ESP32 Component for performing Over the Air updates. The component contains only the handlers. To setup the functions as akri-endpoints handlers, use the <code>esp32-akri</code> component.</p>"},{"location":"components/ota-service/#responsibilities","title":"Responsibilities","text":"<ul> <li>Prepare the board for an OTA firmware update</li> <li>Provide the handler functions to perform the OTA update</li> <li>Handle errors if the OTA update is incomplete</li> </ul>"},{"location":"components/ota-service/#endpoints","title":"Endpoints","text":"<ul> <li>Setup by <code>esp32-akri</code>.</li> </ul>"},{"location":"components/ota-service/#deployment-notes","title":"Deployment Notes","text":"<ul> <li>Packaged as an <code>ESP-IDF</code> component.</li> </ul>"},{"location":"components/ota-service/#how-to-use","title":"How to use","text":"<pre><code>cd &lt;path-to-your-esp-idf-project&gt;\nmkdir -p components\ncd components\ngit clone https://github.com/nubificus/ota-service.git\n</code></pre> <p>Add the component to your project by simply adding the following line inside <code>idf_component_register()</code> of <code>&lt;path-to-your-esp-idf-project&gt;/main/CMakeLists.txt</code>:</p> <pre><code>REQUIRES ota-service\n</code></pre> <p>E.g:</p> <pre><code>idf_component_register(SRCS \"test.c\"\n                       INCLUDE_DIRS \".\"\n                       REQUIRES ota-service)\n</code></pre> <p>You may also have to add the following configuration to resolve some <code>mbedtls</code> issues:</p> <pre><code>idf.py menuconfig\n</code></pre> <p>and enable <code>Component config -&gt; mbedTLS -&gt; HKDF Algorithm (RFC 6859)</code></p> <p>Afterwards, you can include the component's header file:</p> <pre><code>#include \"ota-service.h\"\n</code></pre>"},{"location":"components/ota-service/#api-reference","title":"API Reference","text":"<pre><code>/*\n * this function can be passed as an\n * argument in `akri_set_update_handler()`\n * so that it (only) runs when we receive a\n * POST request at `/update` endpoint.\n * */\nesp_err_t ota_request_handler(httpd_req_t *req);\n</code></pre> <p>The component follows the secure OTA workflow when <code>OTA_SECURE</code> macro is defined. Otherwise, the update is non-secure.</p>"},{"location":"developer/","title":"Overview","text":"<p>The Developer section is intended for contributors and advanced users who want to extend, customize, or integrate with the Cloud-Native IoT platform. It provides the internal architecture details, code structure, and tooling guidance necessary to build and maintain platform components.</p> <p>Whether you're developing new plugins, modifying the onboarding logic, or integrating with third-party systems, this guide will help you understand how the platform works under the hood.</p> <p>What you'll find here:</p> <ul> <li>Application bootstrap: How to structure and code in the logic for your application.</li> <li>Application building &amp; packaging: How to build and package your application.</li> <li>High-level Architecture as a basis to extend the platform: Guidelines for adding new device types, API endpoints, or custom discovery mechanisms.</li> </ul> <p>This section is the go-to resource for anyone looking to contribute to the platform or build custom integrations atop its core functionality.</p>"},{"location":"developer/applications/","title":"Application development","text":""},{"location":"developer/architecture/","title":"System Architecture","text":"<p>Our platform spans cloud, edge, and device layers with secure orchestration, discovery, and task delegation built into each layer.</p>"},{"location":"developer/architecture/#high-level-architecture","title":"High-Level Architecture","text":"<pre><code>+-----------------+\n| Cloud Platform  |\n+-----------------+\n         ^\n         |\n+----------------+   +------------------+    +------------------+\n| Edge Node(s)   |&lt;--| Akri + Offloader |&lt;--&gt;| Neighbor Devices |\n+----------------+   +------------------+    +------------------+\n         ^\n         |\n+----------------+     +-------------------+\n| IoT Devices    |&lt;---&gt;| Onboarding Agent  |\n+----------------+     +-------------------+\n</code></pre>"},{"location":"developer/architecture/#key-components","title":"Key Components","text":"<ul> <li> <p>Onboarding Service: Securely verifies device identity (DICE-based)</p> </li> <li> <p>Akri: Dynamically discovers and exposes verified devices</p> </li> <li> <p>OTA Service &amp; Agent: Secure firmware update management</p> </li> <li> <p>vAccel Offloader: Enables remote compute delegation</p> </li> </ul>"},{"location":"developer/architecture/#technology-stack","title":"Technology Stack","text":"<ul> <li>Kubernetes</li> <li>Akri + CRDs</li> <li>mbedTLS</li> <li>Rust, Go, C, Python</li> </ul>"},{"location":"developer/building/","title":"Application building &amp; packaging","text":""},{"location":"getting-started/","title":"Overview","text":"<p>Whether you're integrating ESP32 microcontrollers or Linux-based devices, our platform facilitates zero-touch provisioning using DICE-based attestation, ensuring device authenticity from the outset. With Akri-based device discovery, you can automatically detect and register devices, creating an up-to-date inventory without manual intervention.</p> <p>For developers and system integrators, the platform offers:</p> <ul> <li>Secure Device Onboarding: Leverage DICE-based mechanisms to authenticate devices during the provisioning process.</li> <li>Seamless OTA Updates: Deploy firmware updates effortlessly to both microcontroller and Linux-class devices.</li> <li>Dynamic Resource Discovery: Utilize Akri to automatically discover and manage connected devices within your network.</li> <li>Task Offloading: Enhance performance by offloading compute-intensive tasks to heterogeneous accelerators using vAccel.</li> <li>Kubernetes Integration: Manage and scale your IoT deployments using Kubernetes-native tools, including Custom Resource Definitions (CRDs) and Operators.</li> </ul> <p>To begin your journey:</p> <ul> <li>Review the Architecture Overview: Understand the core components and their interactions within the platform.</li> <li>Explore the Quickstart Guide: Follow step-by-step instructions to set up your first device and connect it to the platform.</li> <li>Dig into the Installation Guide: Follow step-by-step instructions to set up your first device and connect it to the platform.</li> <li>Dive into Component Details: Gain insights into individual modules like the OTA Service, Akri Integration, and more.</li> <li>Consult the API Documentation: Integrate your applications seamlessly using our comprehensive APIs.</li> </ul> <p>Embark on building scalable, secure, and efficient IoT solutions with the Cloud-Native IoT platform.</p>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/prerequisites/","title":"Prerequisites","text":""},{"location":"getting-started/quickstart/","title":"Quickstart Guide","text":"<p>This guide walks you through the essential steps to deploy the Cloud-Native IoT Platform in a test or development environment.</p>"},{"location":"getting-started/quickstart/#prerequisites","title":"Prerequisites","text":"<ul> <li>Kubernetes cluster (minikube, k3s, or full-fledged cluster)</li> <li><code>kubectl</code> &amp; <code>helm</code> installed</li> <li>containerd runtime</li> <li>ESP32 development board or Linux device (for onboarding test)</li> </ul>"},{"location":"tutorials/","title":"Overview","text":"<p>This section provides step-by-step tutorials to help you get hands-on experience with the Cloud-Native IoT platform. Whether you're onboarding your first device, deploying firmware updates, or integrating with Kubernetes-native tools, these guides are designed to walk you through practical workflows in real-world scenarios.</p> <p>Each tutorial focuses on a specific component or use case, with detailed instructions, commands, and expected outcomes. These examples are ideal for developers, operators, and system integrators looking to understand the inner workings of the platform.</p> <p>What you'll find here:</p> <ul> <li>Platform Setup: Learn how to deploy and configure platform components using containers or Kubernetes manifests.</li> <li>Secure Boot: Setup ESP32 devices with Secure Boot (v1).</li> <li>Secure Boot v2: Setup ESP32 devices with Secure Boot (v2).</li> <li>Initial device flash: Flash a vanilla device.</li> <li>Device Onboarding: Securely register ESP32 and Linux-based devices using DICE attestation.</li> <li>OTA Firmware Updates: Deploy new firmware builds over-the-air, with integrity checks and rollback support.</li> <li>Akri Discovery Integration: Discover and manage devices dynamically in a Kubernetes cluster.</li> <li> <p>Advanced Scenarios: Offload compute to edge accelerators.</p> </li> <li> <p>End-to-end Scenario: Covering all the above steps.</p> </li> </ul> <p>Prerequisites: Basic familiarity with Linux, Docker, and Kubernetes is recommended.</p> <p>Start with a tutorial that fits your use case, or follow the full sequence to gain a comprehensive understanding of the platform.</p>"},{"location":"tutorials/akri-esp32/","title":"Akri ESP32","text":""},{"location":"tutorials/dice-auth/","title":"Dice Authentication","text":"<p>The project is comprised of 2 sub-projects: <code>submit</code> and <code>dice-auth-service</code>.</p>"},{"location":"tutorials/dice-auth/#submit","title":"Submit","text":"<p><code>submit</code> is a program that can be used to submit device entries to a <code>Redis</code> Database. The source code can be found in <code>src/redis_submit.c</code>. First of all, install <code>redis</code>, <code>redis-lib</code> and OpenSSL library:</p> <pre><code>sudo apt-get install redis-server libhiredis-dev libssl-dev\n\n# Now redis should run. You can verify it:\nredis-cli ping\nPONG\n</code></pre> <p>Now you can clone the repository and build <code>submit</code> by running:</p> <pre><code>git clone git@github.com:nubificus/dice-auth.git\ncd dice-auth\nmake submit\n</code></pre> <p>And now you can submit a new device entry to the database by running:</p> <pre><code>./submit UDS(MAC) [redis-IP]\n</code></pre> <p>Internally, <code>submit</code> will generate the Root certificate of the device using the unique device secret (the MAC address) and will submit a new entry to the Redis database. That entry will contain the certificate that will be used later to verify incoming attestation certificates.</p>"},{"location":"tutorials/dice-auth/#list-and-del","title":"<code>list</code> and <code>del</code>","text":"<p>Correspondingly, you can also build the <code>list</code> and <code>del</code> operations, useful for listing the items of the database, or removing an item based on its UDS.</p> <p>Use <code>make ls</code> or <code>make delete</code> to build each one. And use them like:</p> <pre><code>./list [redis-IP]\n./del UDS [redis-IP]\n</code></pre>"},{"location":"tutorials/dice-auth/#dice-auth-service","title":"Dice Auth Service","text":"<p>This is a simple HTTP server that authorizes incoming Attestation certificates. Actually, the server expects <code>POST</code> request that contain the attestation certificate, e.g:</p> <pre><code>curl -X POST &lt;dice-auth-http-endpoint&gt; -H \"Content-Type: text/plain\" --data-binary @/path/to/attestation.pem\n</code></pre> <p>Furthermore, the HTTP server can retrieve the IP of the Redis database from the <code>REDIS_HOST</code> or <code>REDIS_SERVICE_SERVICE_HOST</code> environment variable (in Kubernetes setups, the second variable is probably set automatically). Otherwise, it will attempt to find the database in localhost.</p>"},{"location":"tutorials/dice-auth/#build-and-run","title":"Build and Run","text":"<pre><code>make dice_auth\nmake run\n</code></pre>"},{"location":"tutorials/dice-auth/#cleanup","title":"Cleanup","text":"<pre><code>make clean\n</code></pre>"},{"location":"tutorials/e2e/","title":"Cloud Native IoT Project User's guide","text":"<p>Placeholder document for the end to end scenario</p>"},{"location":"tutorials/e2e/#end-to-end-scenario","title":"End to end scenario","text":""},{"location":"tutorials/e2e/#steps","title":"Steps","text":"<ul> <li>Create script to assign unique and known names to USB devices (based on serialId, vendorId, mac, etc)</li> <li>Create minimal firmware containing OTA functionality and <code>/info</code> endpoint for onboarding</li> <li>Build it with Action (update action to have 2 modes)</li> <li>Flash N devices with minimal firmware (document partition table/secure boot/build settings etc)</li> <li>Create a fresh k3s with latest Akri</li> <li>Deploy our custom operator</li> <li>Deploy our DICE auth server</li> <li>Deploy an onboarding Discovery Handler</li> <li>Post their MAC addresses to DICE auth (automate process)</li> <li>Wait for onboarding Discovery Handler to discover them</li> <li>Deploy 2 additional Discovery Handlers (based on 2 different application types)</li> <li>Use operator to flash X devices with application A and Y devices with application B (leveraging panos' script)</li> <li>Use operator to repurpose 1 or more Devices for application A to B</li> <li>Use operator to upgrade 1 or more Devices to newest firmware version</li> </ul>"},{"location":"tutorials/e2e/#future-tasks","title":"Future tasks","text":"<ul> <li>Implement Dice authentication for the Devices at the onboarding DH step</li> </ul>"},{"location":"tutorials/e2e/#install-akri","title":"Install Akri","text":""},{"location":"tutorials/e2e/#provision-vms","title":"Provision VMs","text":"<pre><code>incus launch images:ubuntu/22.04/cloud cniot01 --project NBFC-long-running-infra --description \"Control plane VM for Akri k3s\" -p default --target @amd64 --vm -c limits.cpu=3 -c limits.memory=4GiB -d root,size=30GiB --vm\nincus launch images:ubuntu/22.04/cloud cniot02 --project NBFC-long-running-infra --description \"Worker VM for Akri k3s\" -p default --target @amd64 --vm -c limits.cpu=2 -c limits.memory=2GiB -d root,size=20GiB --vm\n</code></pre>"},{"location":"tutorials/e2e/#install-k3s-cluster","title":"Install k3s cluster","text":"<p>In the control-plane node:</p> <pre><code>POD_CIDR=\"10.240.32.0/19\"\nSERVICE_CIDR=\"10.240.0.0/19\"\ncurl -sfL https://get.k3s.io | INSTALL_K3S_EXEC='--flannel-backend=none' sh -s - --disable-network-policy --disable \"servicelb\" --disable \"metrics-server\" --cluster-cidr $POD_CIDR --service-cidr $SERVICE_CIDR\n\nsudo addgroup k3s-admin\nsudo adduser $USER k3s-admin\nsudo usermod -a -G k3s-admin $USER\nsudo chgrp k3s-admin /etc/rancher/k3s/k3s.yaml\nsudo chmod g+r /etc/rancher/k3s/k3s.yaml\nnewgrp k3s-admin\n\nPOD_CIDR=\"10.240.32.0/19\"\nkubectl create -f https://raw.githubusercontent.com/projectcalico/calico/v3.29.1/manifests/tigera-operator.yaml\nwget https://raw.githubusercontent.com/projectcalico/calico/v3.29.1/manifests/custom-resources.yaml\nsed -i \"s|192\\.168\\.0\\.0/16|${POD_CIDR}|g\" custom-resources.yaml\nkubectl apply -f custom-resources.yaml\nrm custom-resources.yaml\n\nsudo cat /var/lib/rancher/k3s/server/node-token\n</code></pre> <p>In the worker node:</p> <pre><code>TOKEN=\"mynodetoken\"\ncurl -sfL https://get.k3s.io | K3S_URL=https://cniot01:6443 K3S_TOKEN=$TOKEN sh -\n</code></pre>"},{"location":"tutorials/e2e/#install-metallb-in-the-cluster","title":"Install MetalLB in the cluster","text":"<p>To ensure the IoT devices can talk to the OTA agent, we need to provide the flashjob pod with a routeable IP. We use metallb to do that.</p> <p>First, we need to apply the manifest:</p> <pre><code>VERSION=v0.13.12\nkubectl apply -f https://raw.githubusercontent.com/metallb/metallb/$VERSION/config/manifests/metallb-native.yaml\n</code></pre> <p>Next, we will create an IP pool:</p> <pre><code>cat &lt;&lt;EOF | tee ip-pool.yaml\napiVersion: metallb.io/v1beta1\nkind: IPAddressPool\nmetadata:\n  name: first-pool\n  namespace: metallb-system\nspec:\n  addresses:\n  - 192.168.5.201-192.168.5.230\nEOF\nkubectl apply -f ip-pool.yaml\n</code></pre> <p>Note: This must be a unique range in our subnet. For our e2e example we use 192.168.5.221-230 (max 9 concurrent flashjobs)</p> <p>Finally, we will enable l2 advertisement (this will populate ARP entries across the cluster):</p> <pre><code>cat &lt;&lt;EOF | tee l2add.yaml\napiVersion: metallb.io/v1beta1\nkind: L2Advertisement\nmetadata:\n  name: example\n  namespace: metallb-system\nspec:\n  ipAddressPools:\n  - first-pool\nEOF\nkubectl apply -f l2add.yaml\n</code></pre> <p>Note: This is not needed most probably for this setup, but it's good to have it in case an arp request does not reach the cluster correctly.</p>"},{"location":"tutorials/e2e/#install-akri-in-the-cluster","title":"Install Akri in the cluster","text":"<p>To install Akri we will need Helm:</p> <pre><code>curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash\n</code></pre> <p>Once Helm is installed:</p> <pre><code>helm repo add akri-helm-charts https://project-akri.github.io/akri/\nhelm repo update\nKUBECONFIG=/etc/rancher/k3s/k3s.yaml helm install akri akri-helm-charts/akri\n</code></pre> <p>Verify the Akri Pods are properly deployed:</p> <pre><code>$ kubectl get pods -A | grep akri\ndefault            akri-agent-daemonset-4p249                    1/1     Running     0          43s\ndefault            akri-agent-daemonset-h87nf                    1/1     Running     0          43s\ndefault            akri-controller-deployment-745f4bfc4c-hkg84   1/1     Running     0          43s\ndefault            akri-webhook-configuration-78666f968d-lf875   1/1     Running     0          43s\n</code></pre>"},{"location":"tutorials/e2e/#deploy-flashjob-operator","title":"Deploy Flashjob Operator","text":"<pre><code>cd ~\nsudo apt-get install make -y\ncurl -fsSL https://scripts.gntouts.com/go.sh | bash -s go1.24.2\ngit clone -b uuid_array git@github.com:nubificus/flashjob_operator.git\ncd flashjob_operator\n\nGOPATH=$(go env GOPATH):$PWD make manifests\nGOPATH=$(go env GOPATH):$PWD make install\n\nsudo apt-get install podman -y\nsudo podman login --username gntouts --password &lt;REDACTED&gt; harbor.nbfc.io\ncat &lt;&lt;EOF | sudo tee -a /etc/containers/registries.conf\n[registries.search]\nregistries = ['docker.io']\nEOF\nsudo CONTAINER_TOOL=podman IMG=harbor.nbfc.io/nubificus/iot/flashjob-operator:e2e make docker-build docker-push\nIMG=harbor.nbfc.io/nubificus/iot/flashjob-operator:e2e make deploy\n</code></pre> <p>You should see the Operator Pod running:</p> <pre><code>$ kubectl get pods -A | grep manager\noperator-system    operator-controller-manager-c75bcc686-6lsk2   1/1     Running     0          23s\n</code></pre>"},{"location":"tutorials/e2e/#deploy-dice-auth-server","title":"Deploy DICE auth server","text":""},{"location":"tutorials/e2e/#build-the-dice-auth-server-container-image","title":"Build the DICE auth server container image","text":"<pre><code>cd ~\ngit clone -b feat_submit_mac git@github.com:nubificus/dice-auth.git\ncd dice-auth\nsudo podman build -t harbor.nbfc.io/nubificus/iot/dice-auth-server:e2e .\nsudo podman push harbor.nbfc.io/nubificus/iot/dice-auth-server:e2e\n</code></pre>"},{"location":"tutorials/e2e/#deploy-dice-auth-server-and-redis","title":"Deploy DICE auth server and Redis","text":"<p>The DICE auth server uses Redis as a storage backend. To ensure Redis has persistent storage across reboots an additional storage system for Kubernetes must be installed. In this case, we use Longhorn since it is suggested by the k3s maintainers.</p> <pre><code>sudo apt update\nsudo apt install open-iscsi -y # required by longhorn, make sure to install in both nodes\nkubectl apply -f https://raw.githubusercontent.com/longhorn/longhorn/v1.6.0/deploy/longhorn.yaml\n</code></pre> <pre><code>cat &lt;&lt;EOF | sudo tee deployment.yaml\napiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: redis-data\nspec:\n  accessModes:\n    - ReadWriteOnce\n  storageClassName: longhorn\n  resources:\n    requests:\n      storage: 2Gi\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: redis-deployment\n  labels:\n    app: redis\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: redis\n  template:\n    metadata:\n      labels:\n        app: redis\n    spec:\n      containers:\n        - name: redis\n          image: redis:latest\n          ports:\n            - containerPort: 6379\n          volumeMounts:\n            - mountPath: /data\n              name: redis-storage\n          resources:\n            limits:\n              memory: \"256Mi\"\n              cpu: \"500m\"\n          command: [\"redis-server\", \"--appendonly\", \"yes\"]\n      volumes:\n        - name: redis-storage\n          persistentVolumeClaim:\n            claimName: redis-data\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: redis-service\nspec:\n  selector:\n    app: redis\n  ports:\n    - protocol: TCP\n      port: 6379  # Service port\n      targetPort: 6379  # Pod container port\n  type: ClusterIP  # Change to NodePort or LoadBalancer if external access is needed\n---\napiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: dice-auth-deployment\n  labels:\n    app: dice-auth\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: dice-auth\n  template:\n    metadata:\n      labels:\n        app: dice-auth\n    spec:\n      containers:\n        - name: dice-auth\n          image: harbor.nbfc.io/nubificus/iot/dice-auth-server:e2e\n          imagePullPolicy: Always\n          ports:\n            - containerPort: 8000\n---\napiVersion: v1\nkind: Service\nmetadata:\n  name: dice-auth-service\nspec:\n  selector:\n    app: dice-auth\n  ports:\n    - protocol: TCP\n      port: 8000  # Service port\n      targetPort: 8000  # Pod container port\n  type: ClusterIP  # Change to NodePort or LoadBalancer if external access is needed\nEOF\nkubectl apply -f deployment.yaml\n</code></pre> <p>We should see the Dice auth and Redis Pod running:</p> <pre><code>$ kubectl get pods\nNAME                                          READY   STATUS    RESTARTS   AGE\n...\ndice-auth-deployment-5cfd8b6dc4-qhzg8         1/1     Running   0          107s\nredis-deployment-64dd9d7478-t4rmd             1/1     Running   0          39s\n</code></pre>"},{"location":"tutorials/e2e/#deploy-onboarding-discovery-handler","title":"Deploy Onboarding Discovery Handler","text":"<p>Next, we need to deploy a new Discovery Handler to onboard any devices.</p> <p>To create the new DH we need apply a new Akri Config:</p> <pre><code>controller:\n  enabled: false\nagent:\n  enabled: false\ncleanupHook:\n  enabled: false\nrbac:\n  enabled: false\nwebhookConfiguration:\n  enabled: false\nuseLatestContainers: false\ncustom:\n  configuration:\n    enabled: true\n    name: http-range-onboard # The name of akric\n    capacity: 2\n    discoveryHandlerName: http-discovery-onboard # name of discovery handler, must be unique and matching discovery.name. will be used for socket creation\n    discoveryDetails: | # make sure this is valid YAML\n      ipStart: 192.168.11.20\n      ipEnd: 192.168.11.100\n      applicationType: initial\n      secure: true\n    brokerPod:\n      image:\n        repository: docker.io/gntouts/pause\n        tag: latest\n  discovery:\n    enabled: true\n    image:\n      repository: harbor.nbfc.io/nubificus/iot/akri-discovery-handler-go\n      tag: 61d23fb\n    name: http-discovery-onboard # name of discovery handler, must be unique and matching custom.configuration.discoveryHandlerName\n</code></pre> <pre><code>helm template akri akri-helm-charts/akri -f onboardingConfig.yaml &gt; template.yaml\nkubectl apply -f ./template.yaml\n</code></pre>"},{"location":"tutorials/esp32-initial/","title":"ESP32: Over the air update (OTA)","text":"<p>esp32-ota-update is a vanilla-type firmware for esp32 devices. It doesn't include any actual real world application, however, it can be used to load the necessary tools to perform an OTA update later.</p>"},{"location":"tutorials/esp32-initial/#build","title":"Build","text":"<p>The following commands will build the project.</p> <p>Download esp-idf source</p> <pre><code>cd ~\ngit clone --recursive https://github.com/espressif/esp-idf.git\n</code></pre> <p>Install and set the environment variables</p> <pre><code>cd esp-idf\n./install.sh\n. ./export.sh\n# You have to run the last command every time the environment variables are lost.\n</code></pre> <p>Download the project</p> <pre><code>mkdir projects &amp;&amp; cd projects\ngit clone https://github.com/nubificus/esp32-ota-update.git --recursive\ncd esp32-ota-update\n</code></pre> <p>Security Configuration If you want to use the secure implementation, set the <code>OTA_SECURE</code> environment variable before building. Otherwise, the default configuration is the non-secure.</p> <pre><code>export OTA_SECURE=1\n</code></pre> <p>Build and Flash</p> <pre><code>export FIRMWARE_VERSION=\"0.1.0\"\nexport DEVICE_TYPE=\"esp32s2\"\nexport APPLICATION_TYPE=\"thermo\"\nexport WIFI_SSID=...\nexport WIFI_PASS=...\nidf.py build\nidf.py flash monitor\n</code></pre> <p>Create Docker image</p> <pre><code>export FIRMWARE_VERSION=\"0.1.0\"\nexport DEVICE_TYPE=\"esp32s2\"\nexport APPLICATION_TYPE=\"thermo\"\ntee Dockerfile &gt; /dev/null &lt;&lt; 'EOT'\nFROM scratch\nCOPY ./build/ota.bin /firmware/ota.bin\nLABEL \"com.urunc.iot.path\"=\"/firmware/ota.bin\"\nEOT\ndocker build --push -t harbor.nbfc.io/nubificus/$APPLICATION_TYPE-$DEVICE_TYPE-firmware:$FIRMWARE_VERSION .\nrm -f Dockerfile\n</code></pre> <p>You may have to define the port explicitly</p> <pre><code>idf.py -p &lt;PORT&gt; flash monitor\n# example: -p /dev/ttyUSB0\n</code></pre> <p>Additionally, you may have to change user's rights</p> <pre><code>sudo adduser &lt;USER&gt; dialout\nsudo chmod a+rw &lt;PORT&gt;\n</code></pre> <p>To exit ESP32 monitor</p> <pre><code>Ctr + ]\n</code></pre>"},{"location":"tutorials/esp32-initial/#firmware-provider-app","title":"Firmware Provider App","text":""},{"location":"tutorials/esp32-initial/#non-secure-implementation","title":"Non-secure implementation","text":"<p>In the case of the non-secure implementation, the microcontroller operates as a server, after receiving the post request. Therefore, we need a tcp client to operate as the firmware provider for the microcontroller. The following C program can do this job.</p> <pre><code>/* tcp_client.c */\n\n#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;string.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;errno.h&gt;\n#include &lt;sys/socket.h&gt;\n#include &lt;netinet/in.h&gt;\n#include &lt;arpa/inet.h&gt;\n\n#define SERVER_IP \"192.168.8.62\"\n#define SERVER_PORT 3333\n#define CHUNK_SIZE  1024\n\nvoid send_file(const char *filename) {\n    int sock;\n    struct sockaddr_in server_address;\n    FILE *file;\n    char buffer[CHUNK_SIZE];\n    size_t bytes_read;\n\n    /* Create socket */\n    sock = socket(AF_INET, SOCK_STREAM, 0);\n    if (sock &lt; 0) {\n        perror(\"Error: Socket creation failed\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Define the server address */\n    server_address.sin_family = AF_INET;\n    server_address.sin_port = htons(SERVER_PORT);\n    server_address.sin_addr.s_addr = inet_addr(SERVER_IP);\n\n    /* Connect to the server */\n    if (connect(sock, (struct sockaddr *)&amp;server_address, sizeof(server_address)) &lt; 0) {\n        perror(\"Error: Connection failed\");\n        close(sock);\n        exit(EXIT_FAILURE);\n    }\n\n    /* Open the file */\n    file = fopen(filename, \"rb\");\n    if (!file) {\n        perror(\"Error: File opening failed\");\n        close(sock);\n        exit(EXIT_FAILURE);\n    }\n\n    /* Read from the file and send it to the server in chunks */\n    while ((bytes_read = fread(buffer, 1, CHUNK_SIZE, file)) &gt; 0) {\n    if (send(sock, buffer, bytes_read, 0) &lt; 0) {\n            perror(\"Error: Failed to send data\");\n            break;\n        }\n    }\n\n    printf(\"File %s sent successfully\\n\", filename);\n\n    /* Close file and socket */\n    fclose(file);\n    close(sock);\n}\n\n\nint main(int argc, char *argv[]) {\n    if (argc != 2) {\n        fprintf(stderr, \"Usage: %s &lt;file_path&gt;\\n\", argv[0]);\n        exit(EXIT_FAILURE);\n    }\n\n    send_file(argv[1]);\n    return 0;\n}\n</code></pre> <p>Don't forget to change SERVER_IP. Then, you can build and run the program using the following commands:</p> <pre><code>gcc -o client tcp_client.c\n./client /path/to/file.bin\n</code></pre>"},{"location":"tutorials/esp32-initial/#secure-implementation","title":"Secure implementation","text":"<p>If you build with <code>OTA_SECURE</code>, you will need to check the more advanced OTA Agent implementation, which works with DICE certificates and TLS connection. For more information, view the repository or the documentation.</p>"},{"location":"tutorials/esp32-initial/#simple-firmware-to-use-for-update","title":"Simple Firmware to use for Update","text":"<p>Now we also need to create a simple firmware image, which will be sent by the server to update ESP32. You can use the <code>hello-world</code> example, located in <code>~/esp-idf/examples/get-started/hello_world/</code>. Build with the following commands:</p> <pre><code>cd ~/esp-idf/examples/get-started/hello_world/\nidf.py build\n</code></pre> <p>The new firmware image is located in <code>~/esp-idf/examples/get-started/hello_world/build/hello_world.bin</code>. You can use that file for the ota update by providing the path when running the client.</p>"},{"location":"tutorials/esp32-initial/#multi-platform-image-building","title":"Multi-platform image building","text":"<pre><code>git clone -b feat_http_server git@github.com:nubificus/esp32-ota-update.git\ncd esp32-ota-update\nmkdir -p dist/esp32s2\ntee env.list &gt; /dev/null &lt;&lt; 'EOT'\nFIRMWARE_VERSION=0.2.0\nDEVICE_TYPE=esp32s2\nAPPLICATION_TYPE=thermo\nEOT\ndocker run --rm -v $PWD:/project -w /project espressif/idf:latest idf.py set-target esp32s2\ndocker run --rm -v $PWD:/project -w /project --env-file ./env.list espressif/idf:latest idf.py build\nsudo mv build/ota.bin dist/esp32s2/ota.bin\n\nmkdir -p dist/esp32s3\ntee env.list &gt; /dev/null &lt;&lt; 'EOT'\nFIRMWARE_VERSION=0.2.0\nDEVICE_TYPE=esp32s3\nAPPLICATION_TYPE=thermo\nEOT\ndocker run --rm -v $PWD:/project -w /project espressif/idf:latest idf.py set-target esp32s3\ndocker run --rm -v $PWD:/project -w /project --env-file ./env.list espressif/idf:latest idf.py build\nsudo mv build/ota.bin dist/esp32s3/ota.bin\n\nmkdir -p dist/esp32\ntee env.list &gt; /dev/null &lt;&lt; 'EOT'\nFIRMWARE_VERSION=0.2.0\nDEVICE_TYPE=esp32\nAPPLICATION_TYPE=thermo\nEOT\ndocker run --rm -v $PWD:/project -w /project espressif/idf:latest idf.py set-target esp32\ndocker run --rm -v $PWD:/project -w /project --env-file ./env.list espressif/idf:latest idf.py build\nsudo mv build/ota.bin dist/esp32/ota.bin\n\nsudo chown -R $USER dist\n\ntee Dockerfile &gt; /dev/null &lt;&lt; 'EOT'\nFROM scratch\nARG DEVICE\nCOPY dist/${DEVICE}/ota.bin /firmware/ota.bin\nLABEL \"com.urunc.iot.path\"=\"/firmware/ota.bin\"\nEOT\n\ndocker buildx build --platform custom/esp32 -t harbor.nbfc.io/nubificus/iot/esp32-thermo-firmware:0.2.0-esp32 --build-arg DEVICE=esp32 . --push --provenance false\ndocker buildx build --platform custom/esp32s2 -t harbor.nbfc.io/nubificus/iot/esp32-thermo-firmware:0.2.0-esp32s2 --build-arg DEVICE=esp32s2 . --push --provenance false\ndocker buildx build --platform custom/esp32s3 -t harbor.nbfc.io/nubificus/iot/esp32-thermo-firmware:0.2.0-esp32s3 --build-arg DEVICE=esp32s3 . --push --provenance false\n\ndocker manifest create harbor.nbfc.io/nubificus/iot/esp32-thermo-firmware:0.2.0 \\\n  --amend harbor.nbfc.io/nubificus/iot/esp32-thermo-firmware:0.2.0-esp32 \\\n  --amend harbor.nbfc.io/nubificus/iot/esp32-thermo-firmware:0.2.0-esp32s2 \\\n  --amend harbor.nbfc.io/nubificus/iot/esp32-thermo-firmware:0.2.0-esp32s3\n\ndocker manifest push harbor.nbfc.io/nubificus/iot/esp32-thermo-firmware:0.2.0\n</code></pre>"},{"location":"tutorials/onboarding/","title":"Onboarding","text":""},{"location":"tutorials/ota-service/","title":"ota-service","text":"<p>ESP32 Component for performing Over the Air updates. The component contains only the handlers. To setup the functions as akri-endpoints handlers, use the <code>esp32-akri</code> component.</p>"},{"location":"tutorials/ota-service/#how-to-use","title":"How to use","text":"<pre><code>cd &lt;path-to-your-esp-idf-project&gt;\nmkdir -p components\ncd components\ngit clone https://github.com/nubificus/ota-service.git\n</code></pre> <p>Add the component to your project by simply adding the following line inside <code>idf_component_register()</code> of <code>&lt;path-to-your-esp-idf-project&gt;/main/CMakeLists.txt</code>:</p> <pre><code>REQUIRES ota-service\n</code></pre> <p>E.g:</p> <pre><code>idf_component_register(SRCS \"test.c\"\n                       INCLUDE_DIRS \".\"\n                       REQUIRES ota-service)\n</code></pre> <p>You may also have to add the following configuration to resolve some <code>mbedtls</code> issues:</p> <pre><code>idf.py menuconfig\n</code></pre> <p>and enable <code>Component config -&gt; mbedTLS -&gt; HKDF Algorithm (RFC 6859)</code></p> <p>Afterwards, you can include the component's header file:</p> <pre><code>#include \"ota-service.h\"\n</code></pre>"},{"location":"tutorials/ota-service/#api-reference","title":"API Reference","text":"<pre><code>/*\n * this function can be passed as an\n * argument in `akri_set_update_handler()`\n * so that it (only) runs when we receive a\n * POST request at `/update` endpoint.\n * */\nesp_err_t ota_request_handler(httpd_req_t *req);\n</code></pre> <p>The component follows the secure OTA workflow when <code>OTA_SECURE</code> macro is defined. Otherwise, the update is non-secure.</p>"},{"location":"tutorials/ota-update/","title":"OTA update","text":""},{"location":"tutorials/secure-boot-v2/","title":"Secure Boot V2","text":"<p>Official Documentation</p> <p>This guide provides information on how to enable secure boot V2 on esp32 devices, how to generate V2 keys and how to sign images (or partition tables) based on the V2 security mechanism of esp32 devices and esp-idf framework.</p> <p>Not every esp32 device supports V2 Secure Boot. It's supported by ECO 3 onwards. Furthermore, devices that support V2 Secure Boot, probably support V1, too (see Secure-Boot.md). However, the official documentation mentions that \"It is recommended that users use Secure Boot V2 if they have a chip version that supports it. Secure Boot V2 is safer and more flexible than Secure Boot V1.\"</p>"},{"location":"tutorials/secure-boot-v2/#guide","title":"Guide","text":""},{"location":"tutorials/secure-boot-v2/#step-1","title":"Step 1","text":"<p>First of all, we need an ESP32 Project to use. From the esp-idf repository, you could use <code>examples/get-started/hello_world</code>. Of course, you must have installed esp-idf previously - the repository contains docs. Afterwards, to view some information about the device you are working on, run:</p> <pre><code>esptool.py flash_id\n</code></pre> <p>In the next steps, you will have to set the flash size in menuconfig, as long as the target device.</p>"},{"location":"tutorials/secure-boot-v2/#step-2","title":"Step 2","text":"<p>Set the target device by running:</p> <pre><code>idf.py set-target &lt;dev-target&gt;\n</code></pre>"},{"location":"tutorials/secure-boot-v2/#step-3","title":"Step 3","text":"<p>Set the flash size in your sdkconfig file by using</p> <pre><code>idf.py menuconfig\n</code></pre> <p>And set the right value in <code>Serial flasher config -&gt; Flash size</code></p>"},{"location":"tutorials/secure-boot-v2/#step-4","title":"Step 4","text":"<p>Generate a secure boot signing key v2.</p> <p>Important The keys used to sign binary images (bootloader, application, partition table) in Secure Boot V1 are different than those in V2. This means you can't just use <code>espsecure.py generate_signing_key</code> or use an existing V1 key. The command used to generate V2 keys is the following:</p> <pre><code>espsecure.py generate_signing_key --version 2 --scheme rsa3072 &lt;output-file.pem&gt;\n</code></pre> <p>or</p> <pre><code>openssl genrsa -out &lt;output-file.pem&gt; 3072\n</code></pre> <p>Afterwards, we use use this file for signing images.</p>"},{"location":"tutorials/secure-boot-v2/#step-5","title":"Step 5","text":"<p>Enable Secure Boot V2 in menuconfig: Run</p> <pre><code>idf.py menuconfig\n</code></pre> <p>and select the following options:</p> <pre><code>1. [*] Security features -&gt; Enable hardware Secure Boot in bootloader\n\n2. [*] Security features -&gt; Enable hardware Secure Boot in bootloader -&gt; Select\n   secure boot version -&gt; Enable Secure Boot version 2\n\n3. [*] Sign binaries during build\n\n4. Secure boot private signing key: &lt;key-path.pem&gt;\n\n5. UART ROM download mode: \"Enabled (not recommended)\"\n</code></pre> <p>Regarding the last option, enabling UART ROM download mode lets us flash the board using tools like <code>esptool.py</code> or <code>idf.py flash</code>. However, in production environments where we would like to protect our boards from physical attacks, we should probably set this option to <code>Permanently disabled (recommended)</code>.</p> <p>Furthermore, bootloader binaries are usually larger when secure boot is enabled and partition table default offset <code>0x8000</code> is not enough. You can change that to <code>0x10000</code> in <code>Partition Table -&gt; Offset of partition table</code></p> <p>Before moving forward, I would recommend you to cleanup the directory from previous builds by running:</p> <pre><code>idf.py fullclean\n</code></pre>"},{"location":"tutorials/secure-boot-v2/#step-6","title":"Step 6","text":"<p>Now, to build the bootloader, application image and partition table (and sign them, too), run:</p> <pre><code>idf.py build\n</code></pre> <p>If you would like to build only the bootloader, you could also run:</p> <pre><code>idf.py bootloader\n</code></pre> <p>Those commands will also print instructions on how to flash the bootloader. For example, in my system, the printed message is:</p> <pre><code>==============================================================================\nBootloader built. Secure boot enabled, so bootloader not flashed automatically.\nTo sign the bootloader with additional private keys.\n    /home/ilias/.espressif/python_env/idf5.4_py3.8_env/bin/python /home/ilias/esp-idf/components/esptool_py/esptool/espsecure.py sign_data -k secure_boot_signing_key2.pem -v 2 --append_signatures -o signed_bootloader.bin build/bootloader/bootloader.bin\nSecure boot enabled, so bootloader not flashed automatically.\n    /home/ilias/.espressif/python_env/idf5.4_py3.8_env/bin/python  /home/ilias/esp-idf/components/esptool_py/esptool/esptool.py --chip esp32s2 --port=(PORT) --baud=(BAUD) --before=default_reset --after=no_reset write_flash --flash_mode dio --flash_freq 80m --flash_size keep 0x1000 /home/ilias/esp-idf/examples/get-started/blink/build/bootloader/bootloader.bin\n==============================================================================\n</code></pre> <p>As you can see, esp-idf tells us that Secure boot enabled, so bootloader not flashed automatically. Therefore, we could use recommended command to flash the bootloader. In a more generic form:</p> <pre><code>esptool.py --before=default_reset --after=no_reset write_flash --flash_mode dio --flash_freq 80m --flash_size keep 0x1000 build/bootloader/bootloader.bin\n</code></pre> <p>You may have to define explicitly <code>--chip</code> or <code>--port</code> options. In my case, they were <code>--chip esp32s2</code> and <code>--port=/dev/ttyUSB0</code>.</p>"},{"location":"tutorials/secure-boot-v2/#step-7","title":"Step 7","text":"<p>Now, we can flash the application by using the <code>idf.py flash</code> command. If you have previously built the application using <code>idf.py build</code>, the application binary has been automatically signed and saved in <code>build</code> directory. For the hello-world example, the file is called <code>hello_world.bin</code>. However, if you previously built the bootloader with <code>idf.py bootloader</code>, you now have to run <code>idf.py build</code> to create and sign the application and the partition table. After that, go ahead and run:</p> <pre><code>idf.py flash\n</code></pre>"},{"location":"tutorials/secure-boot-v2/#step-8","title":"Step 8","text":"<p>Finally, we can execute our application by running:</p> <pre><code>idf.py monitor\n</code></pre> <p>and you will see the output of the application on the terminal. Secure Boot is now enabled and works fine if the output is the expected.</p> <p>It's necessary not to lose your private key. Otherwise, you won't be able to reflash your board with new applications, bootloaders or partition tables.</p>"},{"location":"tutorials/secure-boot-v2/#sign-other-images","title":"Sign other images","text":"<p>Sometimes, we may have some already built binaries but they are unsigned. For example, you may have ran <code>idf.py build</code> to a project which is not configured with the secure boot options. This project contains an unsigned application binary file located in <code>build</code> directory (say, app.bin), as well as an unsigned partition table binary file in <code>build/partition_table/</code> (say, partition-table.bin). Saying that, it is possible to sign these files without having to re-build your application. That is possible with the <code>espsecure.py sign_data</code> command. More specifically, you can run:</p> <pre><code>espsecure.py sign_data --version 2 --keyfile PRIVATE_SIGNING_KEY --output build/app-signed.bin build/app.bin\n</code></pre> <p>to sign your application and</p> <pre><code>espsecure.py sign_data --version 2 --keyfile PRIVATE_SIGNING_KEY --output build/partition_table/partition-table.bin build/partition_table/partition-table-signed.bin\n</code></pre> <p>to sign your partition table.</p> <p>Now, based on the offsets configured on the partition table (say, <code>0x10000</code> for the partition table and <code>0x20000</code> for the factory app), you can use <code>esptool.py</code> to flash the signed binaries:</p> <pre><code>esptool.py --before default_reset --after no_reset write_flash --flash_mode dio --flash_size keep --flash_freq 80m 0x10000 build/partition_table/partition-table-signed.bin 0x20000 build/app-signed.bin\n</code></pre> <p>As before, you may have to configure <code>--chip</code> and <code>--port</code>.</p>"},{"location":"tutorials/secure-boot/","title":"Secure boot v1","text":"<p>We worked on enabling secure boot on devices supporting secure boot v1. The following steps summarize the process:</p>"},{"location":"tutorials/secure-boot/#1-create-a-private-signing-key","title":"1. Create a private signing key","text":"<p><code>espsecure.py generate_signing_key secure_boot_signing_key.pem</code></p> <p>IMPORTANT!!! Make sure to save that key. If the key is lost, the device can't be used again after secure boot is enabled!</p>"},{"location":"tutorials/secure-boot/#2-menuconfig","title":"2. Menuconfig","text":"<ul> <li>Security Features</li> <li>Enable hardware Secure Boot in bootloader</li> <li>Secure bootloader mode (Reflashable)</li> <li>Secure boot private signing key -&gt; Path to key</li> <li>Partition Table</li> <li>Offset -&gt; 0x10000</li> </ul>"},{"location":"tutorials/secure-boot/#3-build-the-bootloader","title":"3. Build the bootloader","text":"<p>Better build in a new directory, so the following command prints instructions</p> <p><code>idf.py -B build-secure bootloader</code></p> <p>This command should print some similar instructions as the following ones:</p> <pre><code>Bootloader built and secure digest generated.\nSecure boot enabled, so bootloader not flashed automatically.\nBurn secure boot key to efuse using:\n    $HOME/.espressif/python_env/idf5.4_py3.8_env/bin/python $HOME/esp-idf/components/esptool_py/esptool/espefuse.py burn_key secure_boot_v1 $HOME/ilias/esp-idf/examples/get-started/hello_world/build-secure/bootloader/secure-bootloader-key-256.bin\nFirst time flash command is:\n    $HOME/.espressif/python_env/idf5.4_py3.8_env/bin/python  $HOME/esp-idf/components/esptool_py/esptool/esptool.py --chip esp32 --before=default_reset --after=no_reset write_flash --flash_mode dio --flash_freq 40m --flash_size 2MB 0x1000 $HOME/esp-idf/examples/get-started/hello_world/build-secure/bootloader/bootloader.bin\n==============================================================================\nTo reflash the bootloader after initial flash:\n    $HOME/.espressif/python_env/idf5.4_py3.8_env/bin/python  $HOME/esp-idf/components/esptool_py/esptool/esptool.py --chip esp32 --before=default_reset --after=no_reset write_flash --flash_mode dio --flash_freq 40m --flash_size 2MB 0x0 $HOME/esp-idf/examples/get-started/hello_world/build-secure/bootloader/bootloader-reflash-digest.bin\n==============================================================================\n</code></pre>"},{"location":"tutorials/secure-boot/#4-burn-the-secure-key-on-the-device-can-only-be-written-once","title":"4. Burn the secure key on the device (Can only be written once)","text":"<p>Using the first provided command, we burn the secure key on the device's eFuse:</p> <pre><code>$HOME/.espressif/python_env/idf5.4_py3.8_env/bin/python $HOME/esp-idf/components/esptool_py/esptool/espefuse.py  burn_key secure_boot_v1 $HOME/esp-idf/examples/get-started/hello_world/build-secure/bootloader/secure-bootloader-key-256.bin\n</code></pre> <p>It will print among others: <code>Type 'BURN' (all capitals) to continue.</code></p>"},{"location":"tutorials/secure-boot/#5-flash-the-bootloader","title":"5. Flash the bootloader","text":"<p>You may add the <code>--port</code> argument</p> <pre><code>$HOME/.espressif/python_env/idf5.4_py3.8_env/bin/python  $HOME/esp-idf/components/esptool_py/esptool/esptool.py --chip esp32 --before=default_reset --after=no_reset write_flash --flash_mode dio --flash_freq 40m --flash_size 2MB 0x1000 $HOME/esp-idf/examples/get-started/hello_world/build-secure/bootloader/bootloader.bin\n</code></pre>"},{"location":"tutorials/secure-boot/#6-build-and-flash-the-app","title":"6. Build and flash the app","text":"<p>It will automatically sign the firmware image</p> <p><code>idf.py -B build-secure flash monitor</code></p> <p>The signed firmware is now running.</p>"},{"location":"tutorials/secure-boot/#7-sign-another-image","title":"7. Sign another image","text":"<p>If we want to sign an already built firmware image, we can do so by using the following command:</p> <pre><code>espsecure.py sign_data --version 1 --keyfile ./my_signing_key.pem --output ./image_signed.bin image-unsigned.bin\n</code></pre>"},{"location":"tutorials/secure-boot/#8-flash-the-signed-image","title":"8. Flash the signed image","text":"<p>Afterwards, we can flash the signed app:</p> <pre><code>export BUILD_DIR=/path/to/build_dir/\n\npython3 $HOME/esp-idf/components/esptool_py/esptool/esptool.py --chip esp32 --before default_reset --after hard_reset write_flash --flash_mode dio --flash_size detect 0x10000 $BUILD_DIR/partition_table/partition-table.bin 0x20000 /path/to/image_signed.bin\n</code></pre>"},{"location":"tutorials/setup/","title":"Basic testbed setup","text":""},{"location":"tutorials/vaccel/","title":"vAccel integration","text":""}]}